#pragma once

// NUTSHELL COMPATIBILITY: cashu/core/crypto/b_dhke.py
// Complete Blind Diffie-Hellman Key Exchange implementation compatible with nutshell

#include "cashu/core/crypto/secp.hpp"
#include <string>
#include <vector>
#include <tuple>
#include <optional>

namespace cashu::core::crypto {

/**
 * @brief Domain separator for hash-to-curve operations
 */
extern const std::vector<uint8_t> DOMAIN_SEPARATOR;

/**
 * @brief Generates a secp256k1 point from a message using hash-to-curve
 * 
 * Implementation of hash-to-curve as used in Cashu protocol.
 * The point is generated by hashing the message with a domain separator and then
 * iteratively trying to compute a point from the hash. An increasing uint32 counter
 * (byte order little endian) is appended to the hash until a point is found that lies on the curve.
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param message Message bytes to hash to curve point
 * @return PublicKey point on the curve
 * @throws std::runtime_error if no valid point found after 2^16 iterations
 */
PublicKey hash_to_curve(const std::vector<uint8_t>& message);

/**
 * @brief Convenience overload for string messages
 * @param message String message to hash to curve point
 * @return PublicKey point on the curve
 */
PublicKey hash_to_curve(const std::string& message);

/**
 * @brief Step 1 of BDHKE protocol (Alice's side)
 * 
 * Alice generates blinded point B' = Y + r*G where:
 * - Y = hash_to_curve(secret_message)
 * - r = random blinding factor
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param secret_msg Secret message to blind
 * @param blinding_factor Optional blinding factor (generates random if not provided)
 * @return Tuple of (B', r) - blinded point and blinding factor
 */
std::tuple<PublicKey, PrivateKey> step1_alice(
    const std::string& secret_msg, 
    const std::optional<PrivateKey>& blinding_factor = std::nullopt
);

/**
 * @brief Step 2 of BDHKE protocol (Bob's side)
 * 
 * Bob computes C' = a*B' and generates DLEQ proof
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param B_ Blinded point from Alice
 * @param a Bob's private key
 * @return Tuple of (C', e, s) - signed blinded point and DLEQ proof
 */
std::tuple<PublicKey, PrivateKey, PrivateKey> step2_bob(
    const PublicKey& B_, 
    const PrivateKey& a
);

/**
 * @brief Step 3 of BDHKE protocol (Alice's side)
 * 
 * Alice unblinds the signature: C = C' - r*A
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param C_ Signed blinded point from Bob
 * @param r Blinding factor from step 1
 * @param A Bob's public key
 * @return Unblinded signature C
 */
PublicKey step3_alice(
    const PublicKey& C_, 
    const PrivateKey& r, 
    const PublicKey& A
);

/**
 * @brief Verify that signature C corresponds to secret message
 * 
 * Verifies that C == a*Y where Y = hash_to_curve(secret_msg)
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param a Bob's private key
 * @param C Signature to verify
 * @param secret_msg Original secret message
 * @return True if signature is valid
 */
bool verify(
    const PrivateKey& a, 
    const PublicKey& C, 
    const std::string& secret_msg
);

/**
 * @brief Generate hash for DLEQ proof
 * 
 * Computes e = hash(R1, R2, A, C') for DLEQ proof
 * 
 * @param R1 First proof point
 * @param R2 Second proof point  
 * @param A Bob's public key
 * @param C_ Signed blinded point
 * @return Hash bytes for DLEQ proof
 */
std::vector<uint8_t> hash_e(
    const PublicKey& R1,
    const PublicKey& R2, 
    const PublicKey& A,
    const PublicKey& C_
);

/**
 * @brief Generate DLEQ proof (Bob's side)
 * 
 * Generates Discrete Logarithm Equality proof to prove that
 * the same private key was used in A = a*G and C' = a*B'
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param B_ Blinded point from Alice
 * @param a Bob's private key
 * @param p_bytes Optional deterministic nonce (for testing)
 * @return Tuple of (e, s) - DLEQ proof components
 */
std::tuple<PrivateKey, PrivateKey> step2_bob_dleq(
    const PublicKey& B_,
    const PrivateKey& a,
    const std::vector<uint8_t>& p_bytes = {}
);

/**
 * @brief Verify DLEQ proof (Alice's side)
 * 
 * Alice verifies that Bob used the same private key for A and C'
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param B_ Blinded point that Alice sent
 * @param C_ Signed blinded point from Bob
 * @param e DLEQ proof component e
 * @param s DLEQ proof component s
 * @param A Bob's public key
 * @return True if DLEQ proof is valid
 */
bool alice_verify_dleq(
    const PublicKey& B_,
    const PublicKey& C_,
    const PrivateKey& e,
    const PrivateKey& s,
    const PublicKey& A
);

/**
 * @brief Verify DLEQ proof with original secret (Carol's verification)
 * 
 * Third party can verify DLEQ proof knowing the original secret message
 * 
 * Nutshell compatibility verified: 100% (see tests/hybrid/validate_b_dhke.py)
 * 
 * @param secret_msg Original secret message
 * @param r Blinding factor used by Alice
 * @param C Unblinded signature
 * @param e DLEQ proof component e
 * @param s DLEQ proof component s
 * @param A Bob's public key
 * @return True if DLEQ proof is valid
 */
bool carol_verify_dleq(
    const std::string& secret_msg,
    const PrivateKey& r,
    const PublicKey& C,
    const PrivateKey& e,
    const PrivateKey& s,
    const PublicKey& A
);

// -------- Deprecated functions for backwards compatibility --------

/**
 * @brief Deprecated hash-to-curve (pre-v0.15.0)
 * @param message Message to hash
 * @return Point on curve
 */
PublicKey hash_to_curve_deprecated(const std::vector<uint8_t>& message);

/**
 * @brief Deprecated step1_alice (pre-v0.15.0)
 */
std::tuple<PublicKey, PrivateKey> step1_alice_deprecated(
    const std::string& secret_msg,
    const std::optional<PrivateKey>& blinding_factor = std::nullopt
);

/**
 * @brief Deprecated verify function (pre-v0.15.0)
 */
bool verify_deprecated(
    const PrivateKey& a,
    const PublicKey& C,
    const std::string& secret_msg
);

/**
 * @brief Deprecated Carol DLEQ verification (pre-v0.15.0)
 */
bool carol_verify_dleq_deprecated(
    const std::string& secret_msg,
    const PrivateKey& r,
    const PublicKey& C,
    const PrivateKey& e,
    const PrivateKey& s,
    const PublicKey& A
);

} // namespace cashu::core::crypto